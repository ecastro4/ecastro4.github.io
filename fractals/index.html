<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualitzador Fractal d'Àudio</title>
    <style>
        body { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            min-height: 100vh; 
            background-color: #0d335f; 
            margin: 0; 
            padding: 20px; 
            box-sizing: border-box; 
            font-family: sans-serif; 
        }

        .controls-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            width: 100%; 
            max-width: 600px; 
            margin: 20px auto; 
            padding: 20px; 
            background-color: rgba(255, 255, 255, 0.1); 
            border-radius: 10px; 
        }

        #canvas-container { 
            margin-top: 20px; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
        }

        canvas { 
            border: 2px solid white; 
            max-width: 100%; 
            height: auto; 
        }

        #audio-upload, #shape-selector, #mic-button { 
            margin: 10px 0; 
            padding: 10px; 
            width: 100%; 
            max-width: 300px; 
            border-radius: 5px; 
            border: 1px solid #ccc; 
            box-sizing: border-box; 
        }

        #mic-button { 
            background-color: #4CAF50; 
            color: white; 
            cursor: pointer; 
            border: none; 
        }
        
        #mic-button.active { 
            background-color: #f44336; 
        }
        
        #song-title { 
            color: white; 
            margin-top: 10px; 
            font-size: 18px; 
            text-align: center; 
            min-height: 27px; 
            word-break: break-all; 
        }
        
        .main-title { color: white; 
            text-align: center; 
            margin-bottom: 10px; 
        }
        
        label { color: white; 
            margin-bottom: 5px; 
            font-size: 14px; 
        }
    
    </style>
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
</head>
<body>
    <h1 class="main-title">Visualitzador Fractal d'Àudio</h1>
    <div class="controls-container">
        <label for="audio-upload">Puja un arxiu d'àudio:</label>
        <input type="file" id="audio-upload" accept="audio/*" />
        <label for="shape-selector">Selecciona un fractal:</label>
        <select id="shape-selector">
            <option value="fractal1">Triangle de Sierpinski</option>
            <option value="fractal2">Falguera de Barnsley</option>
            <option value="fractal3">Logo Mitsubishi</option>
            <option value="fractal4">Arbre Fractal</option>
        </select>
        <button id="mic-button">Activar Micròfon</button>
        <h2 id="song-title">Cap arxiu seleccionat</h2>
        <audio id="player" class="plyr" controls loop></audio>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>

    <script>
        let amplitude, fft, mic;
        let selectedShape = 'fractal1';
        let player;
        let isMicActive = false;
        let audioElement;

        function userStartAudio() {
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
        }

        function setup() {
            createCanvas(600, 600).parent('canvas-container');

            amplitude = new p5.Amplitude();
            fft = new p5.FFT(0.8, 256);
            mic = new p5.AudioIn();

            audioElement = new p5.MediaElement(document.getElementById("player"));

            player = new Plyr('#player', {
                listeners: {
                    play: () => {
                        userStartAudio();
                        if (isMicActive) toggleMicrophone();
                        amplitude.setInput(audioElement);
                        fft.setInput(audioElement);
                        loop();
                    },
                    pause: () => {
                        if (!isMicActive) {
                            noLoop();
                            clearCanvasWithMessage("Àudio pausat.");
                        }
                    },
                    ended: () => {
                        if (!player.loop && !isMicActive) {
                            noLoop();
                            clearCanvasWithMessage("Àudio finalitzat.");
                        }
                    }
                }
            });

            player.elements.container.style.maxWidth = '300px';
            player.elements.container.style.margin = '0 auto';

            document.getElementById('audio-upload').addEventListener('change', handleFileUpload);
            document.getElementById('shape-selector').addEventListener('change', function() {
                selectedShape = this.value;
            });
            document.getElementById('mic-button').addEventListener('click', toggleMicrophone);

            noLoop();
            clearCanvasWithMessage("Puja un arxiu d'àudio o activa el micròfon");
        }

        function clearCanvasWithMessage(message) {
            background('#0d335f');
            fill(220);
            textAlign(CENTER, CENTER);
            textSize(18);
            text(message, width / 2, height / 2);
        }

        function toggleMicrophone() {
            userStartAudio();
            const micButton = document.getElementById('mic-button');
            const songTitle = document.getElementById('song-title');
            
            isMicActive = !isMicActive;

            if (isMicActive) {
                if (!audioElement.elt.paused) audioElement.elt.pause();
                
                mic.start(() => {
                    amplitude.setInput(mic);
                    fft.setInput(mic);
                    micButton.textContent = 'Desactivar Micròfon';
                    micButton.classList.add('active');
                    songTitle.textContent = 'Micròfon Actiu';
                    loop();
                }, (err) => {
                    console.error("Error d'accés al micròfon:", err);
                    songTitle.textContent = "Error d'accés al micròfon";
                    isMicActive = false;
                });
            } else {
                mic.stop();
                amplitude.setInput(audioElement);
                fft.setInput(audioElement);
                micButton.textContent = 'Activar Micròfon';
                micButton.classList.remove('active');
                
                const currentFile = document.getElementById('audio-upload').files[0];
                songTitle.textContent = currentFile ? currentFile.name : "Cap arxiu seleccionat";

                noLoop();
                clearCanvasWithMessage("Micròfon desactivat.");
            }
        }

        function draw() {
            background('#0d335f');
            
            let level = amplitude.getLevel();
            let spectrum = fft.analyze();

            let avgFreq = 0;
            if (spectrum.length > 0) {
                avgFreq = spectrum.slice(0, 128).reduce((a, b) => a + b, 0) / 128;
            }

            let scaleFactor = map(level, 0, 0.5, 0.6, 1.6);
            let iterations = floor(map(level, 0, 0.5, 2, 7));

            push();
            translate(width / 2, height / 2);
            if (selectedShape === 'fractal1') {
                drawSierpinskiTriangle(level, avgFreq, scaleFactor, iterations);
            } else if (selectedShape === 'fractal2') {
                drawBarnsleyFern(level, avgFreq, scaleFactor, floor(map(level, 0, 0.5, 2000, 8000)));
            } else if (selectedShape === 'fractal3') {
                drawKochSnowflake(level, avgFreq, scaleFactor, iterations);
            } else if (selectedShape === 'fractal4') {
                drawFractalTree(level, avgFreq, scaleFactor, iterations);
            }
            pop();
        }

        function handleFileUpload(event) {
            userStartAudio();
            let file = event.target.files[0];
            const songTitle = document.getElementById('song-title');

            if (file && file.type.startsWith('audio/')) {
                if (isMicActive) toggleMicrophone();

                let fileURL = URL.createObjectURL(file);

                document.getElementById('player').src = fileURL;

                songTitle.textContent = file.name;
                player.stop();

                noLoop();
                clearCanvasWithMessage("Arxiu carregat. Prem play.");
            } else {
                songTitle.textContent = 'Error: Arxiu no vàlid';
            }
        }

        //FUNCIONS FRACTALS
        function drawKochSnowflake(level, avgFreq, scaleFactor, depthInput) { 
            let baseSize = width * 0.25 * scaleFactor; 
            let depth = constrain(floor(map(level, 0, 0.5, 1, 5)), 1, 5);
            if (depthInput < 1) depth = 1; 
            let hue = map(avgFreq, 0, 128, 0, 360); 
            colorMode(HSL); 
            stroke(hue, 90, 55 + level * 30); 
            strokeWeight(constrain(map(level, 0, 0.5, 0.5, 4), 0.5, 4));
            noFill(); 
            push(); 
            translate(0, -baseSize * 0.15); 
            let p1x = -baseSize / 2, p1y = baseSize * sqrt(3) / 4; 
            let p2x = baseSize / 2, p2y = baseSize * sqrt(3) / 4; 
            let p3x = 0, p3y = -baseSize * sqrt(3) / 4; 
            kochLine(p1x, p1y, p2x, p2y, depth); 
            kochLine(p2x, p2y, p3x, p3y, depth); 
            kochLine(p3x, p3y, p1x, p1y, depth); 
            pop(); 
            colorMode(RGB); 
        }

        function kochLine(x1, y1, x2, y2, depth) { 
            if (depth <= 0) { line(x1, y1, x2, y2); 
                return; 
            } 
            let dx_total = x2 - x1, dy_total = y2 - y1; 
            let xA = x1 + dx_total / 3, yA = y1 + dy_total / 3; 
            let xB = x1 + 2 * dx_total / 3, yB = y1 + 2 * dy_total / 3; 
            let seg_dx = xB - xA, seg_dy = yB - yA; 
            let x_tip = xA + seg_dx * cos(-PI / 3) - seg_dy * sin(-PI / 3); 
            let y_tip = yA + seg_dx * sin(-PI / 3) + seg_dy * cos(-PI / 3); 
            kochLine(x1, y1, xA, yA, depth - 1); 
            kochLine(xA, yA, x_tip, y_tip, depth - 1); 
            kochLine(x_tip, y_tip, xB, yB, depth - 1); 
            kochLine(xB, yB, x2, y2, depth - 1); 
        }

        function drawBarnsleyFern(level, avgFreq, scaleFactor, numPointsInput) { 
            let x = 0, y = 0; 
            push(); 
            translate(0, height * 0.35 * scaleFactor); 
            scale(width * 0.055 * scaleFactor); 
            let numPoints = constrain(floor(numPointsInput), 1500, 10000); 
            let hue = map(avgFreq, 0, 128, 80, 160); 
            colorMode(HSL); 
            stroke(hue, 85, 50 + level * 25); 
            strokeWeight(constrain(map(level, 0, 0.5, 0.1, 1.2), 0.1, 1.2)); 
            for (let i = 0; i < numPoints; i++) { let nextX, nextY, r = random(1); 
                if (r < 0.01) { 
                    nextX = 0; nextY = 0.16 * y; 
                } 
                else if (r < 0.86) { 
                    nextX = 0.85 * x + 0.04 * y; 
                    nextY = -0.04 * x + 0.85 * y + 1.6; 
                } 
                else if (r < 0.93) { 
                    nextX = 0.2 * x - 0.26 * y; 
                    nextY = 0.23 * x + 0.22 * y + 1.6; 
                } 
                else { 
                    nextX = -0.15 * x + 0.28 * y; 
                    nextY = 0.26 * x + 0.24 * y + 0.44; 
                } 
                point(nextX, -nextY); 
                x = nextX; 
                y = nextY; 
            } 
            pop(); 
            colorMode(RGB); 
        }
    
        function drawSierpinskiTriangle(level, avgFreq, scaleFactor, depthInput) { 
            let depth = constrain(floor(map(level, 0, 0.5, 1, 6)), 1, 6); 
            if (depthInput < 1) depth = 1; let size = width * 0.7 * scaleFactor; 
            let hue = map(avgFreq, 0, 128, 180, 300); 
            colorMode(HSL); 
            fill(hue, 90, 55 + level * 25); 
            noStroke(); 
            push(); 
            let x1 = -size / 2, y1 = size * sqrt(3) / 4; 
            let x2 = size / 2, y2 = size * sqrt(3) / 4; 
            let x3 = 0, y3 = -size * sqrt(3) / 4; 
            sierpinski(x1, y1, x2, y2, x3, y3, depth); 
            pop(); 
            colorMode(RGB); 
        }
    
        function sierpinski(x1, y1, x2, y2, x3, y3, depth) { 
            if (depth <= 0) { 
                triangle(x1, y1, x2, y2, x3, y3); 
                return; 
            } 
            let x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2; 
            let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2; 
            let x31 = (x3 + x1) / 2, y31 = (y3 + y1) / 2; 
            sierpinski(x1, y1, x12, y12, x31, y31, depth - 1); 
            sierpinski(x12, y12, x2, y2, x23, y23, depth - 1); 
            sierpinski(x31, y31, x23, y23, x3, y3, depth - 1); 
        }
    
        function drawFractalTree(level, avgFreq, scaleFactor, iterations) { 
            push(); 
            translate(0, height * 0.40 * scaleFactor); 
            let baseLen = constrain(height * 0.18 * scaleFactor * map(level, 0, 0.5, 0.7, 1.3), height * 0.04, height * 0.35); 
            let hue = map(avgFreq, 0, 128, 20, 70); 
            colorMode(HSL); 
            stroke(hue, 80, 45 + level * 20); 
            let initialStrokeWeight = constrain(map(baseLen, height * 0.04, height * 0.35, 1, 12 * scaleFactor) * (0.5 + level), 1, 15); 
            strokeWeight(initialStrokeWeight); 
            branch(baseLen, level, avgFreq, initialStrokeWeight); 
            pop(); 
            colorMode(RGB); 
        }
    
        function branch(len, level, avgFreq, currentStrokeWeight) { 
            strokeWeight(max(0.5, currentStrokeWeight)); 
            line(0, 0, 0, -len); 
            translate(0, -len); 
            let minLenToBranch = Math.max(5, 15 * (1 - level * 0.8)); 
            if (len > minLenToBranch) { 
                let angleVariance = map(avgFreq, 0, 128, -PI / 16, PI / 16) + map(level, 0, 0.5, -PI / 24, PI / 24); 
                let angle1 = constrain(PI / 5 + angleVariance, PI / 10, PI / 3); 
                let angle2 = constrain(PI / 5 - angleVariance / 2, PI / 10, PI / 3);
                let shrinkFactor = constrain(0.67 + map(level, 0, 0.5, -0.05, 0.1), 0.55, 0.78); 
                let nextStrokeWeight = currentStrokeWeight * 0.65; 
                push(); 
                rotate(angle1); 
                branch(len * shrinkFactor, level, avgFreq, nextStrokeWeight); 
                pop(); 
                push(); 
                rotate(-angle2); 
                branch(len * shrinkFactor, level, avgFreq, nextStrokeWeight); 
                pop(); 
            } 
        }
    </script>
</body>
</html>
